# 1 Kafka架构

## 1.1 Producer
消息生产者，就是向kafka broker发消息的客户端。

## 1.2 Consumer
消息消费者，向kafka broker取消息的客户端，
<font color="red">一个消费者可以消费多个分区的数据。一个分区不能被多个消费者消费。</font>

## 1.3 Topic
可以理解为一个队列，主题是一个逻辑概念，用于生产者发布数据，消费者拉取数据。
- Kafka中的主题必须要有标识符，而且是唯一的，
- Kafka中可以有任意数量的主题，没有数量上的限制
- 在主题中的消息是有结构的，一般一个主题包含某一类消息
- <font color="red">一旦生产者发送消息到主题中，这些消息就不能被更新（更改）。</font>

## 1.4 Consumer Group （CG）
这是kafka用来实现一个topic消息的广播（发给所有的consumer）和单播（发给任意一个consumer）的手段。一个topic可以有多个CG。topic的消息会复制-给consumer。

- 一个消费者组中可以包含多个消费者，共同消费topic中的数据
- 一个topic中如果只有一个分区，那么这个分区只能被某个组中的一个消费者消费
- 有多少个分区，那么就可以被组内多少个消费者消费

<font color="red">如果需要实现广播，只要每个consumer有一个独立的CG就可以了。要实现单播只要所有的consumer在同一个CG。用CG还可以将consumer进行自由的分组而不需要多次发送消息到不同的topic。</font>

## 1.5 Broker
一台kafka服务器就是一个broker。
- 一个集群由多个broker组成，这样才能实现负载均衡、以及容错。
- 一个broker可以容纳多个topic。
- broker是无状态（Sateless）的，它们是通过ZooKeeper来维护集群状态。

## 1.6 Partition
为了实现扩展性，一个非常大的topic可以分布到多个broker（即服务器）上，
- 一个topic可以分为多个partition，每个partition是一个有序的队列。
- partition中的每条消息都会被分配一个有序的id（offset）。
- <font color="red">kafka只保证按一个partition中的顺序将消息发给consumer，不保证一个topic的整体（多个partition间）的顺序，如果想提高吞吐，可以设多个分区由多个消费者消费。</font>

## 1.7 Offset
kafka的存储文件都是按照offset.kafka来命名，用offset做名字的好处是方便查找。

例如你想找位于2049的位置，只要找到2048.kafka的文件即可。当然the first offset就是00000000000.kafka。

offset记录着下一条将要发送给Consumer的消息的序号 ，默认Kafka将offset存储在ZooKeeper中。

在一个分区中，消息是有顺序的方式存储着，每个在分区的消费都是有一个递增的id。这个就是偏移量offset
，偏移量在分区中才是有意义的。在分区之间，offset是没有任何意义的。

# 2 分布式模型
Kafka每个主题的多个分区日志分布式地存储在Kafka集群上，同时为了故障容错，每个分区都会以副本的方式复制到多个消息代理节点上。其中一个节点会作为主副本（Leader），其他节点作为备份副本（Follower，也叫作从副本）。

主副本会负责所有的客户端读写操作，备份副本仅仅从主副本同步数据。当主副本出现故障时，备份副本中的一个副本会被选择为新的主副本。因为每个分区的副本中只有主副本接受读写，所以每个服务器端都会作为某些分区的主副本，以及另外一些分区的备份副本，这样Kafka集群的所有服务端整体上对客户端是负载均衡的。

Kafka的生产者和消费者相对于服务器端而言都是客户端。

Kafka生产者客户端发布消息到服务端的指定主题，会指定消息所属的分区。生产者发布消息时根据消息是否有键，采用不同的分区策略。消息没有键时，通过轮询方式进行客户端负载均衡；消息有键时，根据分区语义（例如hash）确保相同键的消息总是发送到同一分区，另外也可以自定义分区。

Kafka的消费者通过订阅主题来消费消息，并且每个消费者都会设置一个消费组名称。因为生产者发布到主题的每一条消息都只会发送给消费者组的一个消费者。所以，如果要实现传统消息系统的“队列”模型，可以让每个消费者都拥有相同的消费组名称，这样消息就会负责均衡到所有的消费者；如果要实现“发布-订阅”模型，则每个消费者的消费者组名称都不相同，这样每条消息就会广播给所有的消费者。

分区是消费者现场模型的最小并行单位。如下图（图1）所示，生产者发布消息到一台服务器的3个分区时，只有一个消费者消费所有的3个分区。在下图（图2）中，3个分区分布在3台服务器上，同时有3个消费者分别消费不同的分区。假设每个服务器的吞吐量时300MB，在下图（图1）中分摊到每个分区只有100MB，而在下图（图2）中，集群整体的吞吐量有900MB。可以看到，增加服务器节点会提升集群的性能，增加消费者数量会提升处理性能。

同一个消费组下多个消费者互相协调消费工作，Kafka会将所有的分区平均地分配给所有的消费者实例，这样每个消费者都可以分配到数量均等的分区。Kafka的消费组管理协议会动态地维护消费组的成员列表，当一个新消费者加入消费者组，或者有消费者离开消费组，都会触发再平衡操作。

<font color="red">Kafka的消费者消费消息时，只保证在一个分区内的消息的完全有序性，并不保证同一个主题汇中多个分区的消息顺序。</font>而且，消费者读取一个分区消息的顺序和生产者写入到这个分区的顺序是一致的。比如，生产者写入“hello”和“Kafka”两条消息到分区P1，则消费者读取到的顺序也一定是“hello”和“Kafka”。如果业务上需要保证所有消息完全一致，只能通过设置一个分区完成，但这种做法的缺点是最多只能有一个消费者进行消费。一般来说，只需要保证每个分区的有序性。